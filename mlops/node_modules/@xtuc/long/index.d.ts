export = Long;
export as namespace Long;

declare namespace Long { }

declare class Long {
    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as signed integers. See the from* functions below for more convenient ways of constructing Longs.
     */
    constructor(low: number, high?: number, unsigned?: boolean);

    /**
     * Maximum unsigned value.
     */
    static MAX_UNSIGNED_VALUE: Long;

    /**
     * Maximum signed value.
     */
    static MAX_VALUE: Long;

    /**
     * Minimum signed value.
     */
    static MIN_VALUE: Long;

    /**
     * Signed negative one.
     */
    static NEG_ONE: Long;

    /**
     * Signed one.
     */
    static ONE: Long;

    /**
     * Unsigned one.
     */
    static UONE: Long;

    /**
     * Unsigned zero.
     */
    static UZERO: Long;

    /**
     * Signed zero
     */
    static ZERO: Long;

    /**
     * The high 32 bits as a signed value.
     */
    high: number;

    /**
     * The low 32 bits as a signed value.
     */
    low: number;

    /**
     * Whether unsigned or not.
     */
    unsigned: boolean;

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is assumed to use 32 bits.
     */
    static fromBits(lowBits: number, highBits: number, unsigned?: boolean): Long;

    /**
     * Returns a Long representing the given 32 bit integer value.
     */
    static fromInt(value: number, unsigned?: boolean): Long;

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     */
    static fromNumber(value: number, unsigned?: boolean): Long;

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     */
    static fromString(str: string, unsigned?: boolean | number, radix?: number): Long;

    /**
     * Creates a Long from its byte representation.
     */
    static fromBytes(bytes: number[], unsigned?: boolean, le?: boolean): Long;

    /**
     * Creates a Long from its little endian byte representation.
     */
    static fromBytesLE(bytes: number[], unsigned?: boolean): Long;

    /**
     * Creates a Long from its big endian byte representation.
     */
    static fromBytesBE(bytes: number[], unsigned?: boolean): Long;

    /**
     * Tests if the specified object is a Long.
     */
    static isLong(obj: any): obj is Long;

    /**
     * Converts the specified value to a Long.
     */
    static fromValue(val: Long | number | string | {low: number, high: number, unsigned: boolean}, unsigned?: boolean): Long;

    /**
     * Returns the sum of this and the specified Long.
     */
    add(addend: number | Long | string): Long;

    /**
     * Returns the bitwise AND of this Long and the specified.
     */
    and(other: Long | number | string): Long;

    /**
     * Compares this Long's value with the specified's.
     */
    compare(other: Long | number | string): number;

    /**
     * Compares this Long's value with the specified's.
     */
    comp(other: Long | number | string): number;

    /**
     * Returns this Long divided by the specified.
     */
    divide(divisor: Long | number | string): Long;

    /**
     * Returns this Long divided by the specified.
     */
    div(divisor: Long | number | string): Long;

    /**
     * Tests if this Long's value equals the specified's.
     */
    equals(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value equals the specified's.
     */
    eq(other: Long | number | string): boolean;

    /**
     * Gets the high 32 bits as a signed integer.
     */
    getHighBits(): number;

    /**
     * Gets the high 32 bits as an unsigned integer.
     */
    getHighBitsUnsigned(): number;

    /**
     * Gets the low 32 bits as a signed integer.
     */
    getLowBits(): number;

    /**
     * Gets the low 32 bits as an unsigned integer.
     */
    getLowBitsUnsigned(): number;

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     */
    getNumBitsAbs(): number;

    /**
     * Tests if this Long's value is greater than the specified's.
     */
    greaterThan(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value is greater than the specified's.
     */
    gt(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     */
    greaterThanOrEqual(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     */
    gte(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     */
    ge(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value is even.
     */
    isEven(): boolean;

    /**
     * Tests if this Long's value is negative.
     */
    isNegative(): boolean;

    /**
     * Tests if this Long's value is odd.
     */
    isOdd(): boolean;

    /**
     * Tests if this Long's value is positive.
     */
    isPositive(): boolean;

    /**
     * Tests if this Long's value equals zero.
     */
    isZero(): boolean;

    /**
     * Tests if this Long's value equals zero.
     */
    eqz(): boolean;

    /**
     * Tests if this Long's value is less than the specified's.
     */
    lessThan(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value is less than the specified's.
     */
    lt(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     */
    lessThanOrEqual(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     */
    lte(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     */
    le(other: Long | number | string): boolean;

    /**
     * Returns this Long modulo the specified.
     */
    modulo(other: Long | number | string): Long;

    /**
     * Returns this Long modulo the specified.
     */
    mod(other: Long | number | string): Long;

    /**
     * Returns this Long modulo the specified.
     */
    rem(other: Long | number | string): Long;

    /**
     * Returns the product of this and the specified Long.
     */
    multiply(multiplier: Long | number | string): Long;

    /**
     * Returns the product of this and the specified Long.
     */
    mul(multiplier: Long | number | string): Long;

    /**
     * Negates this Long's value.
     */
    negate(): Long;

    /**
     * Negates this Long's value.
     */
    neg(): Long;

    /**
     * Returns the bitwise NOT of this Long.
     */
    not(): Long;

    /**
     * Tests if this Long's value differs from the specified's.
     */
    notEquals(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value differs from the specified's.
     */
    neq(other: Long | number | string): boolean;

    /**
     * Tests if this Long's value differs from the specified's.
     */
    ne(other: Long | number | string): boolean;

    /**
     * Returns the bitwise OR of this Long and the specified.
     */
    or(other: Long | number | string): Long;

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     */
    shiftLeft(numBits: number | Long): Long;

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     */
    shl(numBits: number | Long): Long;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     */
    shiftRight(numBits: number | Long): Long;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     */
    shr(numBits: number | Long): Long;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     */
    shiftRightUnsigned(numBits: number | Long): Long;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     */
    shru(numBits: number | Long): Long;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     */
    shr_u(numBits: number | Long): Long;

    /**
     * Returns this Long with bits rotated to the left by the given amount.
     */
    rotateLeft(numBits: number | Long): Long;

    /**
     * Returns this Long with bits rotated to the left by the given amount.
     */
    rotl(numBits: number | Long): Long;

    /**
     * Returns this Long with bits rotated to the right by the given amount.
     */
    rotateRight(numBits: number | Long): Long;

    /**
     * Returns this Long with bits rotated to the right by the given amount.
     */
    rotr(numBits: number | Long): Long;

    /**
     * Returns the difference of this and the specified Long.
     */
    subtract(subtrahend: number | Long | string): Long;

    /**
     * Returns the difference of this and the specified Long.
     */
    sub(subtrahend: number | Long |string): Long;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     */
    toInt(): number;

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     */
    toNumber(): number;

    /**
     * Converts this Long to its byte representation.
     */

    toBytes(le?: boolean): number[];

    /**
     * Converts this Long to its little endian byte representation.
     */

    toBytesLE(): number[];

    /**
     * Converts this Long to its big endian byte representation.
     */

    toBytesBE(): number[];

    /**
     * Converts this Long to signed.
     */
    toSigned(): Long;

    /**
     * Converts the Long to a string written in the specified radix.
     */
    toString(radix?: number): string;

    /**
     * Converts this Long to unsigned.
     */
    toUnsigned(): Long;

    /**
     * Returns the bitwise XOR of this Long and the given one.
     */
    xor(other: Long | number | string): Long;
}
Ò[gïÇhU*&±°b£t[É[µÎ+Å30+y¬œL[9nÆ±«‚9‰UÒ^9K^î™y9-µT±ª´[M3UEDÜÛ§d*aU‰Èò^š 27‚Ë†ËL¿é’½2Õˆ¯,ööÌOëmmNNdpã.2¾¡+ŒÏ‚I¨fs+®”ÂMcnîê’ÖïËºã¼Z¥Ç9@ï‘Î^&‡­*Š4²øÉµ=H§ôÔÌ…‹«IÄ×Ìƒ÷éJ”‘.àîdô)®¸r.¤B¯òEg}NçyÆùâPl‡f£Tùd‚&@:B*:51,âûæ­S3é4LĞ…OŠÊ5éí3|©6İlMX¿8Ün%Î½…ÿ@q —Ò€x0¬Y,™îæÃc¹^?sšmÜİ¸"”¯pjC]¤.N")_ùĞSİ°	¡üô‰vÈ©¥(µGòy<q=ml^HévM£¾YèºÌ® éy<	‡d|6àQÂŠÅr3¡×î>²÷TW‚³Ò*ÕÍbb/Î<<Ø¬‹e_½é;±›mÇqÛß=‹‰É·Bm?²ğŒç‰UŠŒ4³nĞïêˆİµ¾°M*£›C+nøyŞ–MÙ\rÙ¡šzâè`ç`]õµæf6)éÉä¬QŸ†ÍXl™Å«Í©ù!ŠÈˆ4v«ÓG¿²T©Ghš¨"pèpH–áÊ§PgÍöÂÌÉéNÂØ w˜‰Š°ºq+øTêšóM?¾köQÅü™‚¬Üh¯\—ŞŞZ™8a¥2½½½ò0Îêj^èlïÖºƒo”,ÕşÇD§´·Ümhæ°@‡a0NƒôV ~‚Ö­Rí÷é‡#ÿŒƒnDƒ=(C@ÿkunª+ó–hôz½­¾©¸U¢-ï$ˆâ1¹­ÒãS~{*t/H·È˜VqÚ­#r«*mÔ•Åéì•&à¡VsƒêŒØşİø`Aš
×ñbQf8¨ZÕDÑ£ın­#¬éíÚY¨Ï>j¾3fhå¶h?‘Mú®ìXòr£ZÌLÊ\Ğœï}ŸD¦Ğ¿‡!ßBÑdt‡ÙUÿ«Ph%1e—»•œHÑª/ZïC~WüÔ)acÇì ¤ûÄDŸéã;ÌlÅÜRÎjÑË‘İ¨ëµZ›@”|–×GÕÌ‰cAB·T.%å4–ÓïxñÏUoìjÑ»©\Wå$Ş»©*ÏóË8“«än%ÁıîXÑ?ùt)ıÁÜÙ·çN\¥ˆÜ¥‡Sî)u§:äåP¥"®M!µ@+‰ÓJ!IÏÃIz.!­¬¢bLgÁpeÜR¥»–‡TÕbîŒYq§!¬&ÌH†Æ(-Gå®qÊïšUf³ÖØÓœáè8K¾]Š­©QÇëÒ¹–ÒOO–˜]T{¢9·ŒUåŸ%å¤Rù}wy9í¨³ö–+x¥ê†ôÚwà©]©õ=Åh­¿IØ_¥¿ìøF	¹üC÷®AÕ'”:|»ºYNªõUc¦1eÖ6R LÁ€öÆªKı–¼1i‰>
öÙïÕrmë×EëSgxöãv(Š½Ê6£ßŸé§¢ÆŞáÕd¸Ïør«+±ö¡5ª;XC¬5)l?u\-Û·VŠ¢ÒH¾Yf*§¥f¹uĞêh§\ïş—ç§0¿[zõûÉàÖÎ•“ÀNiÍ5Ú÷}Óç×ŠÍ*™š¿pè“ëÿ‘_ü5ãàãJ5şçáã¹ÿÇ×ø+ß’Ø|â­yËÍ
Z÷çyÌÜ¢ÿ—ük?¾t³×ÿ£¥Gÿ¯eºp¾şïÿ·ò&Q5×íõ§¨X7‡šêÑ>mÙ“Ä®ÉÏjõ“éK(‰8}L`±N1(öC(—0õ4’W‰Æ£¿Fƒ"C~ƒª44Ä>GÍóx¤Ç@ã¶|©\cä„7&­1[Ş§üÅ:ü(Î´ôÙ]
¯Yºizğóˆ¹ÀÓäK±¶—_˜ÙÌmMÉïÂ%êš—rÂXëË5ìURzJq{Ïîf˜…7Ö>E˜ÕÓ[tÿKm‡› ªÍú4ó®7‹&(mA¤Ä<*ØÎÿ,¯x++ŞÊÕÿ³üĞ[~Ì¿¿ß\^ó–¼¥¹DSö¯8¹fr¬LëÉäÌi Æ»P„dĞÍ›9DèÇìÖÅŒ,&èõR;0¸]4‹F)õæY§»Òİ1™«Y*Pyõ·÷dÎ¢îç=Nvœ×İ÷éúôÈ[õVò1¥ÔArWp÷B_§ThÕƒ1Ë±êËÚÿš@&ãÅq8™èZçsš‚ÇŞrD©¤¡™ÿy8£Îf7Ñi^Ê¬.{+yéÁwôšq@Îı@ ¯zkÅ~ÊĞ<|˜—àŠn¡ØR¥”A‹qY«)‘èPû<i0†+îwæd§'}i	º‚ÿYêÂàvÏıî?KöÎ—‘PN[Ôì!gzh?ç_G1½¯íL¯ë&“¨ë‡¡÷Gæ#;½_ñ.çµÒs†2ŸK0 ¶•ë8¹´Ô(,(9r–¶Ÿfv#_¢¦äÍ{àçÅ7ÌÖ-”a¯@Êùú‡å÷"/‚„ÅGTĞ,º#eäÖÜ5qigˆT—.UËÖ˜–éI§#,8øNÑ(«nÏ¥øÙH’é„³­âeİnŒ4f2[¥íyƒ+SÒz<X| |l¡ {ÀÃüé€s¸fù¹\“B:ËSç”e6BT9T²mw'ğ¡Í/6fY¶Óàƒ©Í(h†@cê±n>šr¸SÉ2½©î@ñ/×_¾­qÑõ¡îë‚¥×wdo<M¼ël2’†+ÓÅâG>Ğ‰329lçûµíôü 
¯İbExZ^ èvĞÆƒÔbdß8hHÎ'í2a%•Oå*~8Æø¯©õ òUQÑ
€İ±>–¬¢<¸[åd`•G´¦³å/2£Ì¿ÿdıï°·µó²ç†÷ĞÆìûßW×V+úßÒ#Ì	3×ÿîÿïÍ7oc
}Û2òp0:óÒstÚK½ ^„2‹—FH/ÏÚyÉ««+>¿§+¦ŒÒ!EÛ?Œ¯¢0ö‡éÌ†£ÏlâíDıÌÏ&NSõ‰.NÃø*]ÜŞ]<ñ‡gå§ÖôCMb:Çkö/.âzâ|! ÔÆ"ëäù÷]0Ü|²úğ»‡–Ú·Ô—é¢”Ùø‡I6zÇÅ¤ÿÂW#=&£M]z3ğAgÎ¢Í£Ã­íŸ{‡ïmíüØk7ßÊ£!ıäõ¡å˜õ—Oa°ğ¸èèÿŒ*`*R´'gmu‰ÊÀJ'wÖ8h!½Dã:í&ti„ñÜ•Ëd¯¨‰Bú‘5øvæGñ? `Õ«Ü¼ÅcBŠÌµ‡¾ïÓERÛ&GÅ9u‰ô~?Q~2ÀË™½E…¢AS¾ŒÚøEã9ïÓ%˜äqû¡écˆWò%)8|xó¹8FeÖÍc(E†o¿l½ÚµélAÄøñiy1+€‡>çÎ°×Q5¾ıV½Æ”ÁÆ.^7†ëÆññq—[ ˜^éEã(¦ëRFõ_*Ôö¹ôû´Á¾Î‰kq
cÚ0ÉpV7¥ˆÜ9&·–[QÛ$ûªŸúÅ¦$üšÙ4™p[¦¥ö]›‚®cæ\ø÷[u,·ŸÁkşyÌ¦(>l>É8âXvâ`_ù').ªÌ$Ï¥ÖVÿ¨í©]˜7ÿ!\á²‰?ñS—7ºêaãµñè‰ó¶ÕV]jˆš`Ã ¢…	…zXÑä†hq>?lö·a0” y„ÄæŸÄD;@8oğ8÷më[“¼ÁûÒÓöàAï0Xªë'ª¦ææÑ9c<)8ñ“æBG•bÁ×(dÄ!^TuÖ0¦±§C÷¢¤ß?M'£‘Ÿ\@ëäé¢yn<ÏtŒ‰yI)ä¬…W|sÆŠ¯ù´„¿)¸i™òpá%_FÑµÕó0®…_ü$@®´£°ä(@|ÁXØ\6fjÙ^¹<Ì«à=Ç[˜ÊÆœ]XÇfÁ¦1 îåÀ¬ê.€$Íc±=}ºhFD¨9¿ã	Ú<[Êµ)Gæş‡§ÛbœZˆ”Ş³_c&›‚ÒBow§’’*gHñ'à+é$ç^¨3Éfnóå\^S¨ıÎK)wCã5a'ës–…\{ø+ƒş>ª\hSâ‰;9E3-¯¢Å¥T5wµvjC?òÚ¥öãšÚ¹¹S{3¯ûÔ}RS—TzfÜ¤î²A3KÌZ0"¹Â÷Cg‰&	]OvÌ3ul3ˆq¥_ØÄ
#—:Ñ#ÆW…ÆWVK|ª+ñ³x7#Ç›kíl²R¼-Ø„å|c¥ÎTSíÙ™>
´´.ÕœÛK“ØùôxfB;ÚkM¤Âæ`Ø‚ñ»ÅÄ9Yæ©\5‡Rã—ÈáQ‘j&X®)óå&{İLpPªl l)Ãœj )vC¼ÃÈŞwYMì‡ãP¸·ZîÕ^;PÓ¹¿œV ö5±°ÕzÄ×|Ê±H¬kÌ#	‹èI‡–æ…Ä\˜ÿqù!²IXP—çs:f'Î%–q®ã‰ºò#jD5Ïàğ¼Gy“®ÿL!JéÒJaA®¸è`6ËüÍc~ó8ó¿ù.ó„ß<Éß,/Ñ«•%çÕ2¿Zv^­ğ«çÕ*¿Zu^=lã`Kçå£¶ô†SØÉÅC|aõô>Û€NõQL·18˜2_(y¦ËbšuÌ
Ú¨$›Y§ÜT”¤“²9™äQµ¹œ,e˜iåÍ™<Ñ0Ä—g¦r!Éïîk™ìgüP“²æÓÅÔ9ë6aZ§Ò"fùá­XOt6Á+PLnxÛe“¹h½”=KG¤÷•3H×f‘.V—øRi˜[¦HCåO²¹À@nBÔQ)^¹Ç³ÓO¨ÉA­ZA!Ã"&)|”C®ÍN-ngVU1
ßvá^‹ñ¦Eõ<N®üdÚİuàNÏŠeQ$ÇÙ¤¯ ¥ã.ÄÁÈ¨¹RòuáBöÚİäd÷P8FBrÆKJÙ~’à€¡j—áh³ë½éõ`‹™²¿¡î$ÿ´I%Õ)ÀêÑ©×V‡2if3$úYÇèÎí<Ô—ız…xÛ„IJézP×‡À:à‹I±‹	ípv-ÛŞı£q¥ã¿¤İç„íî'M{	2º.ÈıË)êù¬¿#›õ¯ø0–zií5¢¶2ö0¿Æ;@(âš®ÿÀ»º ¯âpË\í5¾ÓíYãµ‹«0X¦¾>•/Ø9E{A€WŠãS %b2„$ ,pU6véTœÆpŒwT¡:§Wyû ->ş€™=éÂ+OĞÜÈËR¼«*EoOıJ7›Ğ£8ŸÚÙÃó'Û8ğ¥'ÁPã>Ÿ:Ö$”Ğ˜´ˆÇ2 æÁæŠĞºgXxqààŞ¦”{cs¢ø\¹BÚÃ’[	ô£SÃ79ïZˆŒ ê08ƒëğm1*–‰zÃw0rÁv>U@4â40”ÁğôfAeSÏú;j¥; /S'©¯AxEñ*†÷ ³ü*²s`$û8·şæá½«$°bŞ»k´°ë?5™q\$Ã!_rv&í,ãl^câYMuŠÔñÆB^³ÆÄãW‹'ÀxG ÿëd±ßÛ~}¸{ô›7¶¹£l´ES4ÒåuŒ¶+Ü…Q­œD$C!DsW®š‚æd³¦0Áß±IgÓ|À`­x°±#«²ºm®¯£•Š‚3sìnuÇÚŠ®•½KV‰€ÒÅE záõ·,s”Mš©†®ÂæË‘2D”/X‡fA–Å[{qFéº \~n† ¾›F :¦19&yü¸`¡ )Î±6º‚H—É?”äø.0ø6Iy˜•›œø}ñi%ã‡G”´Q®ô UÃn½”ûï˜EcÏŒ.öŠ,r„§NÉ¸Ã±:	"ÜéäôŸï1:Ác‰w
ˆD¿8Q!0œlÉŠÌ†¦ ˆ.1œúŒärÎOHŒĞ1,ñt‚Èd÷s_Ej7r¯™
@°iì’}TŸ¢1 Slèp,&£ÔL€%©gMætÉæÊbõRcßÕš-á§1Šzr»²os“uiXÒÙ9fè(áÁ›g*™›ñà†ã‚°:¤Í âÕRÒa~å³Çj¡Ù#ÈLäo^•¥Ø­
5:„Gú–ÙÚäVAYNf½ĞÅÜnçå‚h¦Y a¶æ„€#cÌ;B¢{¡;4 Ü»7S‘(òéâ‘•ùJL›*%'7|æ3#*¸…ãµsÈ\¹CVêZ‡…€FCæÑğØÌ˜M¿e÷rôïãÈ“Ìu°Q±ôÛ[¾ñv8º¶8Â¼œG¾ºÏ½“]¤!„øgxó>g¹K.ª"‰ŠrYù‰E>è<;ä0é Â‘i´æC°La¤y‡q+2Ç*äåøœÄR°¶Ò(ö7ÉrÇ=Ç­É]†ˆ5²CXÉĞp’ğ;;9pRº–^\Um¢î}D‰¿eó’‚Òh”ËÏŞ®V/ÂRú2/±©;†ZqT>°9FîÆAûÅ0ñs5ÆÍ£ˆèŸâ­xü‚åĞSÜÙp” í5éäTƒİP§Ï»Ù¡S.ƒ4›0dŞaUu0ÊÜînpaçšÔÑ$è{<LpJÜW'xÂÙªQRÅ”ˆb.*»W>qñ5ôÈÜñ•;äSlSA ÈÛxv:êwYºré”îQ½âŠ“ˆÓO22´†§å†.´“zFI!MçmGI3 ‹7É‹´›ˆÕãÍu(måB5eÔ'İÛäÀ'Ê½ËÏ€+ºfgê^½tlÎûïiP•pĞ(U¾M–¼%º%³¸ç§°öät‚‰³‰|gˆü*ô¯Ñ»¯Ó%0¶I–)9îä!ÃóJ4eç¤UÈĞ=íº››?dı´xÛq¢°DÙ'Ï8ÃùW‡Ù3Ğ-ÛÈj]ÊÍâDÓ+Mï²3[@‘Ë»G¡ßª(B …¤3Ô¡Ğ%R®+0%h4~C¥®D¢Rsö:V¡¤+½p©Íe¦~`J-ô:æ(å24GUÊÁS	Id$X± Í1öÔ‹ø
÷ÇgÒôçu8,PœÆğ‰è”²|‘e Æó–”ç‡œi—kğ%2T:;g¾l. [‚,4’²„Ò8µš‹9 ebH#œñ áVHäÅgQç´a@ è£?¢{%5x‘ßğ]9¤g"¼¢£w LôŸ„µ:Iffò°K¯1´yù0ŒñşLœ]ºç%sª3jSèù@r0=51	„—h×œ8™œj-é¹“é©×h!È&õ±#Bì–EÑıádtrÜfŞÇ't&—WØ©›X f·¶lJN²|«Z¨qÀÆ‰ßuu"s„á¡Üq+ëÑIúÆF”¦@e'rË0\Šà¡eöŒ´ümh²Äºä­‰Gˆ·¤ïi”ĞA²æÅ`ïïÕdŒµêºf¢#óJá#ÿÂä­@2*²âGìèÁ< É9ı»¸ğ>ğq*’}9ß""ât¸ŠrãoZ*ÿĞ–diÚ+EÃºØàH–Õv*w—‚¹º¦ Šğ¥ÚæÃ­0·GìÖQ6|s¨ÏzÆê’òŸ0U£„(Ş"şRjOÍ5Íõ^4ƒÕ'‹X<Nı°Ë	^º—]„Ün40'İson×KAÇ¿XZ0Ô![>j<l¾ËÇ¥0Âÿ¡”Lø½G,º¡íïj¢†!^è®­œ2vñ–&ô–;.%ß‹ şbç—ÚæˆNõ¼İš´1ÊÊÉÿr¬ˆYxÆ€ ÎßI*£¥§¹sêüoş7ÿ»×¿ÿ=,GÓ @ 