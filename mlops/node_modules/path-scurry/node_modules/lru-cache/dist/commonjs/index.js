"use strict";
/**
 * @module LRUCache
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LRUCache = void 0;
const perf = typeof performance === 'object' &&
    performance &&
    typeof performance.now === 'function'
    ? performance
    : Date;
const warned = new Set();
/* c8 ignore start */
const PROCESS = (typeof process === 'object' && !!process ? process : {});
/* c8 ignore start */
const emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === 'function'
        ? PROCESS.emitWarning(msg, type, code, fn)
        : console.error(`[${code}] ${type}: ${msg}`);
};
let AC = globalThis.AbortController;
let AS = globalThis.AbortSignal;
/* c8 ignore start */
if (typeof AC === 'undefined') {
    //@ts-ignore
    AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
            this._onabort.push(fn);
        }
    };
    //@ts-ignore
    AC = class AbortController {
        constructor() {
            warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
            if (this.signal.aborted)
                return;
            //@ts-ignore
            this.signal.reason = reason;
            //@ts-ignore
            this.signal.aborted = true;
            //@ts-ignore
            for (const fn of this.signal._onabort) {
                fn(reason);
            }
            this.signal.onabort?.(reason);
        }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';
    const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
            return;
        printACPolyfillWarning = false;
        emitWarning('AbortController is not defined. If using lru-cache in ' +
            'node 14, load an AbortController polyfill from the ' +
            '`node-abort-controller` package. A minimal polyfill is ' +
            'provided for use by LRUCache.fetch(), but it should not be ' +
            'relied upon in other contexts (eg, passing it to other APIs that ' +
            'use AbortController/AbortSignal might have undesirable effects). ' +
            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);
    };
}
/* c8 ignore stop */
const shouldWarn = (code) => !warned.has(code);
const TYPE = Symbol('type');
const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
/* c8 ignore start */
// This is a little bit ridiculous, tbh.
// The maximum array length is 2^32-1 or thereabouts on most JS impls.
// And well before that point, you're caching the entire world, I mean,
// that's ~32GB of just integers for the next/prev links, plus whatever
// else to hold that many keys and values.  Just filling the memory with
// zeroes at init time is brutal when you get that big.
// But why not be complete?
// Maybe in the future, these limits will have expanded.
const getUintArray = (max) => !isPosInt(max)
    ? null
    : max <= Math.pow(2, 8)
        ? Uint8Array
        : max <= Math.pow(2, 16)
            ? Uint16Array
            : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                    ? ZeroArray
                    : null;
/* c8 ignore stop */
class ZeroArray extends Array {
    constructor(size) {
        super(size);
        this.fill(0);
    }
}
class Stack {
    heap;
    length;
    // private constructor
    static #constructing = false;
    static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
            return [];
        Stack.#constructing = true;
        const s = new Stack(max, HeapCls);
        Stack.#constructing = false;
        return s;
    }
    constructor(max, HeapCls) {
        /* c8 ignore start */
        if (!Stack.#constructing) {
            throw new TypeError('instantiate Stack using Stack.create(n)');
        }
        /* c8 ignore stop */
        this.heap = new HeapCls(max);
        this.length = 0;
    }
    push(n) {
        this.heap[this.length++] = n;
    }
    pop() {
        return this.heap[--this.length];
    }
}
/**
 * Default export, the thing you're using this module to get.
 *
 * The `K` and `V` types define the key and value types, respectively. The
 * optional `FC` type defines the type of the `context` object passed to
 * `cache.fetch()` and `cache.memo()`.
 *
 * Keys and values **must not** be `null` or `undefined`.
 *
 * All properties from the options object (with the exception of `max`,
 * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are
 * added as normal public members. (The listed options are read-only getters.)
 *
 * Changing any of these will alter the defaults for subsequent method calls.
 */
class LRUCache {
    // options that cannot be changed without disaster
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
        return {
            // properties
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
                return c.#head;
            },
            get tail() {
                return c.#tail;
            },
            free: c.#free,
            // methods
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
        };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
        return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
        return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
        return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
        return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
        return this.#fetchMethod;
    }
    get memoMethod() {
        return this.#memoMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
        return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
        return this.#disposeAfter;
    }
    constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;
        if (max !== 0 && !isPosInt(max)) {
            throw new TypeError('max option must be a nonnegative integer');
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
            throw new Error('invalid max value: ' + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');
            }
            if (typeof this.sizeCalculation !== 'function') {
                throw new TypeError('sizeCalculation set to non-function');
            }
        }
        if (memoMethod !== undefined &&
            typeof memoMethod !== 'function') {
            throw new TypeError('memoMethod must be a function if defined');
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== undefined &&
            typeof fetchMethod !== 'function') {
            throw new TypeError('fetchMethod must be a function if specified');
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = new Map();
        this.#keyList = new Array(max).fill(undefined);
        this.#valList = new Array(max).fill(undefined);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === 'function') {
            this.#dispose = dispose;
        }
        if (typeof disposeAfter === 'function') {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
        }
        else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        // NB: maxEntrySize is set to maxSize if it's set
        if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
                if (!isPosInt(this.#maxSize)) {
                    throw new TypeError('maxSize must be a positive integer if specified');
                }
            }
            if (!isPosInt(this.maxEntrySize)) {
                throw new TypeError('maxEntrySize must be a positive integer if specified');
            }
            this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0
                ? ttlResolution
                : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
            if (!isPosInt(this.ttl)) {
                throw new TypeError('ttl must be a positive integer if specified');
            }
            this.#initializeTTLTracking();
        }
        // do not allow completely unbounded caches
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError('At least one of max, maxSize, or ttl is required');
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = 'LRU_CACHE_UNBOUNDED';
            if (shouldWarn(code)) {
                warned.add(code);
                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +
                    'result in unbounded memory consumption.';
                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);
            }
        }
    }
    /**
     * Return the number of ms left in the item's TTL. If item is not in cache,
     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
     */
    getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
                const t = setTimeout(() => {
                    if (this.#isStale(index)) {
                        this.#delete(this.#keyList[index], 'expire');
                    }
                }, ttl + 1);
    LF-*"2Cp|Kr=p9oHrSMfa*R3+pP`T_,ex!`"B:$;c8czsl.{LSƓxbTֈh
/Ұ@'ڂ zc;`FG*c̈́G`&n?|4.ֳ`/o9(9>L6^AN`1 6PcDǷ% QbƐi*AvNPub镜n0T镈R?=fT|Ct=y#-k/*epRH|Uz=G
Y'+Yfsc2ݤ:u@<,.Ro cEBľcv2E37*Ze4䏗A'ɰv<RA^w	!X$'e3ʺ0a ')|TD2^mH,rK'V()l3,,R!Cݤ誣2{FTRTL/7)H۸\uNI0x Mk a
w1YDx1~(}_@NAy.OMfLOQt[[zR^8"L4aa8DNi;	$`z.h ~l-ˋRqL.;@$e2ħ4zz;tvdݓIt[[x.}kؙC_,luxwe|nF'h? !$i%k49(r)#q)+n);Vlg-e&-e-eG.e-cu(Kx%~2CZgNUMT^{zulü@$E1(|6qG?yDM
8x13U3nSˮRvY]v5w^.(>;oo73K$'].V9`+HnKB^l^cq4HiX(.93z"iy-g	q "
'{=[.4 	H4P '2=nAjаFr4*n*A	_crJO,cW8O̜.C5\DKL5D?aeJ.{, ''L $M*oҪ["V'͖SO6pO'_Ѝ^GĉzON?Fߏ|VJHV _]tWPxKӋZawP(=VtQeÆiw 9Wַ%c}R!8N'Pa~M	}ӷ:̔HCjERz!j9ވ}Sl=׃3 R`kOre:dIFUVls쐡>0gV`Ob	%VqAJ3ߟ8E%B݈#02+{
KŴ#TCuk;ճӺ/AFks0~H E,
684drl7yҜ*7bB Y74Y
A~cS > <-wOEtvAlZ\Hi*(tʗљwt%ΡH3'Dġ@pXp=T.!#O:cʲ]Ce[\p,.M%TOxqbB+bf؞D.qa&4DG*6_&޸?@A/I:pNͨ8WDwނzF	@q:sqpuWDԦQ.CdLAJrmFFGCZ X  wh!5gTX3bɎ.N+b+21J$xuF	Ϳ{LKv_N2Tr͓/vuԾφoV9?q>VሬMᛷ-ޥ(-cb,UGAEHܖo撔BD-
1|܏FwDm!rq<
5g1"Gx<獵j=-?-geQg/	
WP@b5y!(AxL$OQl;qgQoYyS.ߖPG+]ƴ!ӊEi࿉o@!Q"-I@V Zk@PeP{ow^8e/USأ4P̈KPW+bzӽĉ#(8_|CT;ԧ0R|.\IeUt#2>Ri٢R>.i3~F-{/MG熤əR{$uHIꞹ`P
?T<R~y2|	xZ>o.'a-XӶ>s*A:">}R\I?mliWS!&II^ZU~L3U)-J-PHlGhbSXky#qH~$0.S&2^^&ї\V\q7	ΊjhcYA6p*!H"JRci41F",w`f/U[^]ޕUH}8/C`ՎhDܪ7r1~%$4"EMSii $,PT[lD}(gvIdu/Wd"ie+P5jIyk'KTOxjC*p._r0PT>)'fN08+xHd1&t6?q'T?
fU6;ZN?$fb;VbTUj$@bFS -x^/yoyDo`)Re89QHYǬ1AN6X9Z8v4].Ұ!z(uB43WiUF	,RJT 6:hl;MQ]kqu>ʵ8_pRЀzvF\NxQdq2}C 0[g$h<L"TXfI9 f[-rU:ցH^1/#)lSW6.;c;q:B/sDZ$)|ٳwx3u$5,xĒn+Px8x|
>TGf8rLo*]U,Z=L%K4&1;IK֚&0yKTFAqGJcϬPצ1AR2wTc. $Y_(ڙ;>QNMY2O'͕)IFg<
Ղ+c_'@fSܫУyPWMO5hٚęqfVd;Y{NYwm*4Zˢ%v5D2/v87}vFdM>U˥fE( ƣi^kt;xo;#shAͲN98L4'Z{Z(<=_rrMly>D˙>ǩ>Oyd5ޜgw=d&2/UCfzSzO*)ӽ{&|55,bT˗
s慠ITeս6'HJԁXuyQHUnNL*a\&tT*n*,LL<X䴛OM(( vv	aP%[db%V G,W³A~3#kK=Z{iB1WYp3p"^$ANrb3ӛgveat\Xx_ql>
g=888ɕu!XY8[E^a03lDt㤫Sr%D~mj"d2N&+Tv>ǿ(M&v0ѐ͢vM#+'yΣ|bSS67C4KRQ-9Ut3MG+$ΗƁoptr3>˓:Zغ)ǺFR?º,E4(Lk*Y<-
IҰZ5P ԢNzE\qճMkD'}afbr,ڑxڈV׻0]XưfUp\#+soecn%=;~~OCU%pЧܨhzh&.s"	b?ěp5%U7Frn
G?z	~=᫤FA`=Hue%Dʟqm$IoΜfwOcc3YWІ,ww"rFyR~O
aв%r0,l"3on=:¯@]Q7nS9]l+\o00Jxx%tahSK9uOÓ?\m	*|Ȧ	UaTP8XYPRp1T#Zk3ghe/(2{=iZ~|5&}ZY%Of=' s?it =Q-fn{\0撱7v%E[ck*O7b1Ą4t9l/آr
}x-nxm''Npk,Q9Moe0ERϸK).Ժ6+1˒{R;`ݮCў눽R$$t侀ˠI-= lXFN|eF줜$E9"Z3cD[:	d\1׬Eg2Pj8G]+Abrit7ޓ~l{!WwFUde/)x?O%&Yfh`u'd^j*GrlR<Fsڍ<1dXN9̸266b&ީR@Nꍇ(
H/cIA)&\5lc`=6M64Q$Ki]<~XբŪZv,;x5_5p'iajlHnd/uɶD6䯴0ANCM
vp}r\++ok[+o_t4,Ȯav=sd?>+Cv`sg~=<h` V
Ee!".o(BO;,çz%>W8W]D_{>Մ_ꄘz(yj?L
f%aemK۽\`˚Y-C"zLe\I_+o"MH+VK[TGĊy+wX"++7htezz
b)ŋu2t2ޯBƱx#;;[;(l@pGE^qE$[$J0.~Ļ @iR*(ߓG]HReu0k,nO_C%Mql-:KNec΃$:zds'@EO"T)9+DI؍Z2(lDb2;j:Xᠧ0Wjñ˵aȦ8|xCGIHj	J}O -\WB5F9M-o5hJG!B%)Q>02 Hxi,C qU%쟵'h
^ zs}]QP1-E"U! Np"vfFwhVgTKA"+02S
^vrM 2u)eYP $gJ\S&1A8F~)Hzk7dt~z4E%=?ǿmB9,81$#>ণ.>ZLuf"Ol(˵BEJESRJU]/OE+{''IZYbҤ7*H)ꉦjJT->}FC{1=ñ+>F {B:uAsD#+CcJvQzERa|_h$ma_a+
9B[Ѹ$Vﰻ~8
ֆ:EYI-+ƣ{sŌyUx	iQT+9WCˤmsGb \:&z|<*Vͪ,9tb!tWU(Y]Q޳.*K'Teҧϥ%U*[)oum}u.}o<iT&a<$B<]q)*Knt),QN.#^:h :!vԯ(LʘTYe["ǹ|_U&n`B.zQPgZkn~Zobnt11L=[e3|d^u7?md:$JY.KlƏ\/x.jQw4D"dqb<h
]xhMDtGog9m_w(Ex(^/ĲE<C`rҶQ7Bɣz|<v(Rp#aP.=j[fjZzFfFzg[`+#$Egk}:gAgG;3fmxhx\zz/G4ִ aQ{@]֊t+3
C&ۉk'ds>j{)ԁ+!Ryn4
Ql>pE kN=Օh[ƣc=?wD?ucS5b{mGf]6u}}멻֓DGܝpR[WwݻE}v@	yҩ+(&$/,H5٘Q֛f]8vn01KT^E/
^
1;@%`1rs1/i+}P_FPg~?}z0I5baQJh	HWA,XEMpTj>]4%/z(԰a+Zá$dV:!U"\kǌ]:Qli\+0CJYc;1yɊAoYv&ࡏTx>pg=~]~V33uR;uiDn5:0m2;BmrH/9=< iiu1I.(n
+O~Vq5)za*;-l'4W)dy91)O^`"xF=ߩݝz\dJo9iYd"TJ%arl/\i"¶V i܂fvX3S%56lD]f1kQdǅV?)wi"A8Sr7ֲjiړvO?)e(턓le'UKgh2d³LdDK2ZOo>zv'/d9.	h*1sXJJKmcz%4K&H47!RNa&1X?2ql[OnnkN>>g[6&Bf8u@cx3"'7+o0Ma*XKEV]^c2.J4bqx/sJ%~@򇱼#t|<X3N^5WAra~	`~۟Y+<|RmDx{2Dnc[^]IF@$`u1u_xdbI/0=wXZMlm}o^/1&;ՍkJyukv߶{㘂`@:Q=ZLsdxtZ`0B{|(|bׄr-;*jxT0-LbHl^D֒~`@Ħ%$N`bZ/,r'덖8Ȟ2[,
<lOəv~1_2[I1sRQ2o-]0)e;l:K)A,D2z~K0.y1,FfuY^`6ac觚!L0iL?a 0%fR9;eF#\*U*
> 6L@5|\QޝF*)0e	˩&YIVrI@s7quKr۩'2DJSb} ;We2n4oy{Gt,Elڠ5(@3!qQ<$q3TqIi,MIOEfI8tJrJi?dP0dJmL1)-8sOrJQ\ȿ	[ޚnhյ__/O*08Њiм8s񾰣KrFVH<>B2*5M{6<q>8wJA$-qwS1l=*YxF}\/,zN梇# FQ_гḘ̄{9(*-WE@Pkk"l(Kh5$IX29ʋ ʱH0{\y/'x!PMк^$֕%c-)ȫހoUa鑟BWdo%6)"1¦0(h?WANŌ)aJ0&,S؝BA\(ANe*SUۙp@iQ
  u@gw@MJYa2ޕ-7DwBySN%!U2Sl505TbbC\͠jOMDbkXn{wJU%>c[B4@-IPҝ}=WKBĸGؕ^uȁ qUl A-.1婛]pd=2bHSvR-s$HOTY+9NҨdį*f.vĩa~^Uޖ3px%D<@jwz4ݩUwGZw7R(Xx9@o}\g]IFh	vVnf&VzU/b;1odwvNu#l;u!.vQ[V$ޔ+fǌf<0&LLjb>O;03H0IIHPȀY#MhiML#FO{ϳUDm<QʓmÁ-c~H:Jۑfs7sG
	1wg=u_۽SmOu3vFNO}
F\7^ίb7RnR6e2LU=Crtk	N&܃jD\_\w0Cae\qUo/oh{n9[Πc*QqgL㑣'GOʹ1	{UިJc"B1 w(zͺH4VQW<UD DE+@OI40'F[{zB"[+hZꐔ?gȷwA}zbf+Cښ71~Pv"ոB5wD_h|cM{6~+xχTpAl$|r%ζyr2]8>Y?Ĕ#$ $zO(5+ 1h0)lH˨$:./j* <fɊ1 >}b%<`i6<6;9qĐfoUa~F#b<	{26yUZGoRY(:UOd4OBQ1"9) XO
Kye7s{wLv.z{=nzW[6[[VLH\%!Yl0OL'
RpR/5;tzC7aKۯoHºgYz}Xcafm5ݻ09mK(P eؿs+KGEyG!}㕄#{F;Z(-hT	ه
1kxQL&QVwʙޭA[fɞa3u3e|.Y>lHU&Y&lHKlN6/j<hnf>ب1.FiGkqXJr`Hf߿W7y^Y<T3[{]w_7*~&*)1KUSV)O/+׍c7h_52xe55QKU@/I7?"8Ao5_7Vޯ_i6 ~dBGU =>PH@r`A?`,h?67s{o}Imq|JLp)E3:f"i؍	g%#meox7X'9 ىG3+vpM_0	&.#iH&x.6#򬼀'"sܽ/='J ^ăO 3"ܗ<-iER>n}-kH
$ܺ>E{uЎ\L53Lۦ%jXdIbf#TU㡴RUCm|y2nuPVIvyUE61:VVr)_eއ![+_v|tٔYxUoI;0j5vaBN9͘CL##M;֦ȽP_sS_VÄ  